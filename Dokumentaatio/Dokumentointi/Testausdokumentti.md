Testaaminen
-------

Ohjelman ratkaisualgoritmi toimii kaikilla peleillä samalla tavalla; pelitilanteesta konstruoidaan uudet pelitilanteet siirtämällä tyhjää pelilaattaa kaikkiin mahdollisiin suuntiin ja uudet tilanteet lisätään prioriteettijonoon. Prioriteettijonossa pelitilanteet järjestetään nousevaan järjestykseen pelitilanteelle lasketun prioriteettiarvon perusteella. Jonosta uudeksi tarkasteltavaksi pelitilanteeksi valikoituu prioriteettiarvon perusteella ratkeamisen kannalta optimaallisimmalta näyttävä pelitilanne. Koska jokainen pelitilanne ratkeaa samalla kaavalla, algoritmin tehokkuus perustuu sopivan prioriteettiarvon laskevan funktion valintaan. Prioriteettiarvon laskevasta funktiosta käytetään yleisesti myös nimitystä heuristiikkafunktio. Mitä tarkemman arvion heuristiikkafunktio antaa kyseisen pelitilanteen ratkeavuudesta, sitä paremmin pelitilanteet voidaan järjestää jonoon. 

Suoritin ratkaisualgoritmilleni kahdenlaisia testejä: algoritmin toimintaan liittyviä testejä sekä algoritmin suorituskykyyn liittyviä testejä. Algoritmin toimintaan liittyvän testauksen toteutin Javan JUnit-yksikkötestauksella. Kirjoitin testit kaikelle mielestäni algoritmin toiminnan kannalta oleelliselle sisällölle. JUnit testien tarkempaa sisältöä voi tarkastella projektikansioni Test-alikansiosta. Suorituskykytestausta suoritin läpi koko projektin pyrkiessäni löytämään erilaisille pelitilanteille mahdollisimman hyvän heuristiikkafunktion.

Suorituskykytestit
------

Algoritmin suorituskykyä testasin sekä 3x3 että 4x4 kokoisilla pelilaatikoilla. Loin metodin, joka konstruoi ja ratkaisee 1000 erilaista pelitilannetta. 3x3 kokoinen pelilaatikko, eli 8-peli, osoittautui erittäin nopeaksi ratkaista mistä tahansa alkutilanteesta. 8-pelin keskimääräinen ratkaisuaika oli alle millisekuntti, ratkaisun löytämiseen vaadittiin noin 29 siirtoa ja keskimääräinen prioriteettijonon koko oli 457 pelitilannetta. Koska 8-peli on erittäin nopea ratkaista, ei sen suorituskyvyn tarkastelu ole kovin mielekästä. Sen sijaan 15-pelin (4x4 laatikko) ratkaisuaikojen vaihtelu oli riittävän suurta, jotta tuloksista olisi mielekästä tehdä jonkinlaisia johtopäätöksiä. Alla olevassa kuvassa on kuvattu 100 ensimmäisen 15-pelin ratkaisuajat, siirtojen lukumäärät sekä prioriteettijonon koot. Selkeyden vuoksi tilanteista, joissa ratkaisuajat ovat samat, on siirtojen lukumääräksi ja prioriteettijonon kooksi laskettu keskiarvo. Tälläisiä tilanteita syntyi lähinnä vain niiden pelitilanteiden kohdalla, jotka ratkesivat alle 10 millisekunnissa.  

![Diagnostiikka] (Diagnostiikka.png)

Keskimäärin 15-peli ratkeaa noin 77 millisekunnissa, löydetyssä ratkaisussa on 88 siirtoja ja keskimääräinen prioriteettijonon koko on 46635 pelitilannetta. Näyttäisi siltä, ettei minimisiirtojen lukumäärä, jolla ratkaisuun voidaan päästä, anna mitään osviittaa siitä, kuinka nopeasti algoritmi ratkaisee kulloisenkin alkutilanteen. Sen sijaan ratkaisuaika ja prioriteettijono koko kasvavat lähestulkoon toisiinsa verrannollisesti. Tässäkin on havaittavissa vaihtelua, mitä kauemmin algoritmilla kestää ratkaisun löytämisessä. Vaihtelun voi selittää se, että joissain tapauksissa algoritmi lähtee tarkastelemaan useampaa lähes yhtä "hyvää" pelitilannetta, joista pahimmillaan mikään ei johda lopputulokseen. 

Pienet optimoinnit ja kompromissit
-------
Kaiken kaikkiaan käyttämäni heuristiikka funktio erilaisten pelitilanteiden arvottamiseen on kompromissi ratkaisuajan ja minimisiirtojen lukumäärän suhteen. Mikäli algoritmin ratkaisuajoista haluttiin pahimmillaankin alle muutaman sekunnin pituisia, lisääntyi minimisiirtojen lukumäärä hieman. Loppujen lopuksi päädyin lopputulokseen, joka antaa löytää ratkaisun 1,3 kertaisella siirtojen lukumäärällä kuin mitä niitä minimissään vaadittaisiin. Koska optimiratkaisun siirtojen lukumäärän selvittäminen on eksponentiaalinen ongelma, kerroin 1,3 ei ole absoluuttinen, vaan antaa vain hieman osvittaa, missä suuruusluokassa liikutaan. Tähän kertoimeen päädyin testaamalla 10-20 erilaista alkutilannetta, jonka minimisiirtojen lukumäärän tiesin.

Pyrin optimoimaan koodiani sitä mukaa kun projektini eteni. Suurin osa optimoinneista oli erilaisten metodikutsujen ja laskennan minimoimista. Isolle osalle optimoinneista en suorittanut tarkempaa suorituskykytestausta, sillä en kokenut niiden olevan merkittäviä optimointeja algoritmin kannalta. Ehkä merkittävimmin algoritmin ratkaisuaikaan vaikuttava optimointi tehosti uuden pelitilanteen arvon laskemista. Alun perin laskin jokaiselle uudelle pelitilanteelle uuden heuristiikka funktion arvon lähtien täysin nollasta. Tämä ei kuitenkaan ollut tarpeellista, sillä uuden pelitilanteen arvon pystyy myös laskemaan tehokkaammin sen pelitilanteen arvosta, josta uusi pelitilanne konstruoidaan. Koska jokainen uusi pelitilanne konstruoidaan siirtämällä tyhjää laattaa, johonkin suuntaa, muuttuu pelitilanteen arvo vain siirtosuunnassa olevan pelilaatan osalta. Näin ollen kaikkien laattojen läpikäynnin sijasta riittää, että tarkastellaan vain tilannetta, jossa yksi laatta on vaihtanut paikkaa tyhjän laatan kanssa. Kyseisen optimoinnin ansioista algoritmi ratkaisee 15-pelin noin. 10-20 % nopeammin kuin alkuperäinen algoritmi. Mitä kauemmin algoritmilla kestää löytää ratkaisu(useampi konstruoitu pelitilanne), sitä enemmän kyseinen optimointi vaikuttaa.
